joacosm
joacosm
Escuchando Ralphie Choo

joacosm ‚Äî 11/04/2025 21:59
Imagen
joacosm
 ha iniciado una llamada que ha durado 2 horas. ‚Äî 15/04/2025 10:21
joacosm ‚Äî 03/05/2025 11:08
.
q onda llamen
joacosm
 ha iniciado una llamada que ha durado unos segundos. ‚Äî 03/05/2025 11:11
joacosm ‚Äî 03/05/2025 11:11
ok
entiendo
lo hare solo
SAL
 ha iniciado una llamada que ha durado un minuto. ‚Äî 03/05/2025 11:11
joacosm ‚Äî 03/05/2025 11:51
https://drive.google.com/file/d/1N9gM2JK9a4pg2zE-IG1fZQPrUPTCtjw4/view?usp=sharing
Google Docs
Diagrama sin t√≠tulo
https://drive.google.com/file/d/1N9gM2JK9a4pg2zE-IG1fZQPrUPTCtjw4/view?usp=sharing
Google Docs
Diagrama sin t√≠tulo
https://drive.google.com/file/d/1N9gM2JK9a4pg2zE-IG1fZQPrUPTCtjw4/view?usp=sharing
Google Docs
Diagrama sin t√≠tulo
SAL ‚Äî 03/05/2025 11:58
https://drive.google.com/file/d/1BMsxaJ_UCWtNkP1zfCPHi_uJosh2HHkE/view?usp=sharing
Google Docs
SHST-diagrama-conceptos-de-negocio.drawio
joacosm
 ha iniciado una llamada que ha durado 8 minutos. ‚Äî 09/05/2025 10:55
joacosm
 ha iniciado una llamada que ha durado unos segundos. ‚Äî 10/05/2025 10:30
joacosm ‚Äî 18/05/2025 18:27
q eso
Tipo de archivo adjunto: acrobat
AyDS2025_11- Modelo_Casos_Uso-Descripcion (1).pdf
1.19 MB
Tipo de archivo adjunto: acrobat
Receta tacos de spagetti.pdf
194.26 KB
SAL ‚Äî 18/05/2025 18:55
Me estaba pasando algo del celu a la compu de valen
joacosm ‚Äî 19/05/2025 13:25
informe estapa 1 https://docs.google.com/document/d/1EoMdNU8cHdfs8pQYiFClBeEdRKNkAtdk_uLzeTSKTsg/edit?tab=t.0#heading=h.lmsdxfy1zoj9
Google Docs
informeGrupo2
Introducci√≥n Esta primera etapa del proyecto consiste en el dise√±o de un sumador de 8 bits con arquitectura de √°rbol Carry Look-Ahead (CLA Tree Adder) que, como funcionalidad adicional, es capaz de detectar condiciones de overflow durante la operaci√≥n. A diferencia de los sumadores convenciona...
Imagen
SAL ‚Äî 21/05/2025 15:50
Tipo de archivo adjunto: document
Analisis tp4.docx
91.57 KB
Tipo de archivo adjunto: unknown
Tp4e3.drawio
24.62 KB
SAL ‚Äî 21/05/2025 16:13
https://docs.google.com/document/d/1wb6oTsgfWlTtOoBzkVFzbIuyLeBZ5DScVfomOoWqNEU/edit?usp=sharing
Google Docs
APUNTES AYDS
An√°lisis y Dise√±o de Sistemas Software Instrucciones (programas de c√≥mputo), procedimientos, reglas, documentaci√≥n y datos asociados que forman parte de las operaciones de un sistema de computaci√≥n (IEEE) Ingenier√≠a de software Es el √°rea de las ciencias de la computaci√≥n que estudia la construc...
Imagen
joacosm ‚Äî 21/05/2025 16:31
Tipo de archivo adjunto: document
Analisis tp5.docx
133.75 KB
Tipo de archivo adjunto: unknown
tp5e1.drawio
2.89 KB
joacosm ‚Äî 21/05/2025 17:11
Tipo de archivo adjunto: document
Analisis tp4.docx
209.02 KB
joacosm ‚Äî 01/06/2025 16:15
metete al canal de los reales
joacosm
 ha iniciado una llamada que ha durado 5 minutos. ‚Äî 04/06/2025 11:09
joacosm
 ha iniciado una llamada que ha durado una hora. ‚Äî 04/06/2025 11:50
SAL ‚Äî 04/06/2025 11:51
Imagen
joacosm ‚Äî 04/06/2025 16:35
Tipo de archivo adjunto: acrobat
Parcial de Analisis y Dise√±o de Sistemas.pdf
75.25 KB
SAL ‚Äî 04/06/2025 16:48
Tipo de archivo adjunto: acrobat
1 Parcial de Analisis y Dise√±o de Sistemas.pdf
344.56 KB
Tipo de archivo adjunto: acrobat
2do parcial 2023.pdf
242.79 KB
SAL
 ha iniciado una llamada que ha durado 42 minutos. ‚Äî 08/06/2025 15:36
Tienes una llamada perdida de 
SAL
 que ha durado unos segundos. ‚Äî 13/06/2025 10:20
SAL ‚Äî 23/06/2025 18:17
Tipo de archivo adjunto: spreadsheet
Ej2ParcialARQUI - Copy.xlsx
13.66 KB
joacosm
 ha iniciado una llamada que ha durado unos segundos. ‚Äî 28/06/2025 17:48
joacosm ‚Äî 28/06/2025 17:49
estas onlai
SAL
 ha iniciado una llamada que ha durado 6 minutos. ‚Äî 28/06/2025 17:52
joacosm
 ha iniciado una llamada que ha durado 16 minutos. ‚Äî ayer a las 16:14
joacosm
 ha iniciado una llamada que ha durado 3 minutos. ‚Äî ayer a las 16:31
joacosm ‚Äî ayer a las 16:33
al final no se q paso esta igual
ahora sigo con lo que quede
nos vemos
joacosm
 ha iniciado una llamada que ha durado 15 minutos. ‚Äî ayer a las 19:57
joacosm ‚Äî ayer a las 20:28
che
desde cuando se muestra el cartel de nuevo maximo?
SAL ‚Äî ayer a las 20:29
512 creo
joacosm ‚Äî ayer a las 20:29
mmm raro
pq no se elimina niguno ahi
sisi ahi probe
joacosm ‚Äî 18:28
Generaci√≥n aleatoria del bloque a disparar.

    Para determinar el valor del pr√≥ximo bloque, se utiliza un predicado que recibe la grilla actual y calcula un valor aleatorio v√°lido seg√∫n las reglas del juego.

    El proceso comienza identificando el valor m√°ximo actual de la grilla. En funci√≥n de este valor, se define un rango m√≠nimo y m√°ximo dentro del cual se permite generar el siguiente bloque.

    En las primeras etapas de la partida, el rango se establece mediante condiciones fijas basadas en el valor m√°ximo. Sin embargo, cuando el valor m√°ximo supera los 16.000, se aplica una f√≥rmula espec√≠fica que ajusta el rango de forma proporcional al avance del juego.

    Esta f√≥rmula calcula la cantidad de veces que el valor m√°ximo se ha duplicado respecto de 16.000. La cantidad de duplicaciones se obtiene utilizando el logaritmo base 2. A partir de este valor, se determina el rango permitido seg√∫n las siguientes expresiones:

    M√≠nimo permitido = 2 elevado a (5 + K)

    M√°ximo permitido = 2 elevado a (10 + K)

    Donde K representa la cantidad de duplicaciones del valor m√°ximo actual respecto de 16.000, calculada como:

    K = piso de log‚ÇÇ(MaxAct / 16000)

    De esta manera, por cada duplicaci√≥n del valor m√°ximo, el rango permitido se desplaza a valores m√°s altos de forma controlada y progresiva.

    Una vez determinado el rango, se filtran todas las potencias de dos dentro de esos l√≠mites y se selecciona aleatoriamente una de ellas como pr√≥ximo bloque a disparar.
joacosm ‚Äî 19:19
La manera en la que se eval√∫a si se mostrar√° el aviso de "Combo xN" est√° completamente manejada en el frontend. Para esto, se aprovecha la misma consulta de disparo que se utiliza para obtener el estado actualizado de la grilla y los efectos que produce la jugada.

    Cuando el jugador dispara un bloque, la respuesta de Prolog incluye una lista de efectos que detallan los cambios ocurridos durante esa jugada. Cada efecto tiene dos componentes:

        -La grilla resultante luego de ese paso.

        -Una lista interna de informaci√≥n adicional, que puede incluir, entre otras cosas, los nuevos bloques generados como resultado de fusiones.

    Desde el frontend, no es necesario realizar consultas extra ni c√°lculos adicionales sobre la grilla. Lo que se hace es recorrer esta lista de efectos y contabilizar cu√°ntos de esos efectos tienen una lista de nuevos bloques (newBlock) no vac√≠a. Cada vez que esa lista contiene al menos un bloque, significa que se produjo una fusi√≥n en ese paso.

    Una vez realizada esta contabilizaci√≥n, si la cantidad de fusiones detectadas es mayor o igual a 3, se activa el aviso en pantalla "Combo xN", donde N corresponde a la cantidad total de fusiones encadenadas en esa jugada.
SAL ‚Äî 19:24
Al igual que en el juego original, si en una efecto se fusionarion varios bloques diferentes, igualmente se considera como un √∫nico aumento en el combo. Esta decisi√≥n busca reflejar fielmente el comportamiento del juego base.
joacosm ‚Äî 19:37
El booster de bloque siguiente est√° implementado del lado del frontEnd. Al iniciarse la partida por primera vez, durante la inicializaci√≥n del juego (init), se consultan dos bloques aleatorios: uno para ser el primero en disparar, y otro que queda en espera como siguiente bloque.

Independientemente de si el booster est√° activado o no, esta l√≥gica se ejecuta de todas formas. Es decir, luego de disparar el bloque actual, este se reemplaza directamente por el valor previamente asignado como "bloque siguiente", y reci√©n entonces se realiza una nueva consulta para generar un nuevo bloque siguiente.

El bot√≥n asociado al booster no altera esta mec√°nica. Su √∫nica funci√≥n es alternar entre mostrar u ocultar el valor del pr√≥ximo bloque, pero no modifica el hecho de que siempre se calcula por adelantado. Gracias a este dise√±o, se garantiza que el bloque actual haya sido, en todos los casos, el bloque siguiente antes de ser utilizado.
# Informe de la Resoluci√≥n del Proyecto
*M2 Blocks - L√≥gica para Cs. de la Computaci√≥n - 2025*

**Comisi√≥n `46`**:
- `Salamanca, Santiago`
- `Santa Mar√≠a, Joaqu√≠n`
---
Dadas las principales funcionales a ser contempladas tal como estan presentadas en el repositorio de GitHub, a continuacion se describir√° como se implementaron.

    - <span style="color:#fc7f40">üìå**Aviso "Combo x N.**</span> 

    La manera en la que se eval√∫a si se mostrar√° el aviso de "Combo xN" est√° completamente manejada en el frontend. Para esto, se aprovecha la misma consulta de disparo que se utiliza para obtener el estado actualizado de la grilla y los efectos que produce la jugada.

    Cuando el jugador dispara un bloque, la respuesta de Prolog incluye una lista de efectos que detallan los cambios ocurridos durante esa jugada. Cada efecto tiene dos componentes:

        -La grilla resultante luego de ese paso.

        -Una lista que puede incluir, los nuevos bloques generados como resultado de fusiones (si es que los hay).

    Desde el frontend, no es necesario realizar consultas extra ni c√°lculos adicionales sobre la grilla. Lo que se hace es recorrer esta lista de efectos y contabilizar cu√°ntos de esos efectos tienen una lista de nuevos bloques (newBlock) no vac√≠a. Cada vez que esa lista contiene al menos un bloque, significa que se produjo una fusi√≥n en ese paso.

    Una vez realizada esta contabilizaci√≥n, si la cantidad de fusiones detectadas es mayor o igual a 3, se activa el aviso en pantalla "Combo xN", donde N corresponde a la cantidad total de fusiones encadenadas en esa jugada.

    Como en el juego original, si en un efecto se fusionan varios bloques distintos, esto a√∫n se cuenta como un solo incremento en el combo. Esta elecci√≥n intenta representar con precisi√≥n el comportamiento del juego base.
    
- <span style="color:#fc7f40">üìå**Generaci√≥n aleatoria del bloque a disparar.**</span> 

    Generaci√≥n aleatoria del bloque a disparar.

    Para determinar el valor del pr√≥ximo bloque, se utiliza un predicado que recibe la grilla actual y calcula un valor aleatorio v√°lido seg√∫n las reglas del juego.

    El proceso comienza identificando el valor m√°ximo actual de la grilla. En funci√≥n de este valor, se define un rango m√≠nimo y m√°ximo dentro del cual se permite generar el siguiente bloque.

    En las primeras etapas de la partida, el rango se establece mediante condiciones fijas basadas en la tabla proporcionada por la catedra en github. Sin embargo, cuando el valor m√°ximo supera los 16.000, se aplica una f√≥rmula espec√≠fica que ajusta el rango de forma proporcional al avance del juego.

    Esta f√≥rmula calcula la cantidad de veces que el valor m√°ximo se ha duplicado respecto de 16.000. La cantidad de duplicaciones se obtiene utilizando el logaritmo base 2. A partir de este valor, se determina el rango permitido seg√∫n las siguientes expresiones:

    M√≠nimo permitido = 2^(5 + K)

    M√°ximo permitido = 2^(10 + K)

    Donde K representa la cantidad de duplicaciones del valor m√°ximo actual respecto de 16.000, calculada como:

    K = piso de log‚ÇÇ(MaxAct / 16000)

    De esta manera, por cada duplicaci√≥n del valor m√°ximo, el rango permitido se desplaza a valores m√°s altos de forma controlada y progresiva.

    Una vez determinado el rango, se filtran todas las potencias de dos dentro de esos l√≠mites y se selecciona aleatoriamente una de ellas como pr√≥ximo bloque a disparar.
- <span style="color:#fc7f40">üìå  **Efecto del disparo de un bloque.**</span> 

    Como parte de las optimizaciones implementadas, se tuvo en cuenta el costo de calcular repetidamente la longitud de la grilla (mediante `length/2`) y la redundancia de que multiples predicados realicen el calculo agregando lineas de codigo que podrian omitirse. Para evitar este sobrecosto, se definieron dos variantes del predicado `shoot`:

    - Una primera versi√≥n se activa √∫nicamente la primera vez que se invoca el disparo. En esta se calcula la longitud total de la grilla y se utiliza `assert/1` para guardar este valor como un hecho din√°mico en la base de conocimiento. Luego, procede con su normal funcionamiento.

    - A partir de entonces, una segunda versi√≥n de `shoot` se encarga de verificar si ese hecho ya existe. Si es as√≠, procede normalmente con `shoot`.

    Esta t√©cnica permite evitar c√°lculos redundantes sin afectar el comportamiento l√≥gico del juego, mejorando ligeramente la eficiencia sin introducir complejidad significativa.

    Para resolver el efecto de disparo de un bloque, el problema fue subdividido en tareas individuales que, combinadas, permiten alcanzar el objetivo. Esta fragmentaci√≥n tambi√©n permiti√≥ la reutilizaci√≥n de predicados en otras partes del juego.

    Primero, se dise√±√≥ un predicado encargado de insertar el bloque reci√©n disparado en la grilla. Esto significa que, dado el bloque y la columna de disparo, el predicado lo ubica en el √∫ltimo espacio vac√≠o de esa columna antes de encontrarse con un bloque existente o el final de la grilla.

    Este proceso se realiza sobre la grilla, que est√° representada como una lista unidimensional. Dada la cantidad de columnas y la columna seleccionada, se calculan los √≠ndices correspondientes a esa columna. Luego se recorren esos √≠ndices, desde los m√°s bajos hasta los m√°s altos, buscando una celda vac√≠a (representada por un gui√≥n). Si no hay espacio disponible, el predicado no realiza cambios. Si logra insertarlo, se retorna la nueva grilla junto con el √≠ndice de inserci√≥n.

    Una vez insertado el bloque, entra en juego el predicado m√°s importante del sistema: el encargado de identificar y ejecutar las fusiones disponibles, respetando las reglas del juego original.

    ### üîπ Estructura jer√°rquica de resoluci√≥n de fusiones

    El n√∫cleo de la l√≥gica del juego se basa en tres niveles de predicados encadenados de forma jer√°rquica:

    #### 1. `admin` (nivel superior):

    Controla el ciclo completo del disparo de un bloque. Se encarga de:

    - Invocar a `bucle` para identificar fusiones iniciales  a partir del √≠ndice del nuevo bloque.
    - Aplicar la gravedad una vez que se realizaron fusiones.
    - Invocar nuevamente `bucle` para revisar nuevas posibles fusiones  que puedan haber surgido tras la ca√≠da de bloques y fusiones previas.

    > Como t√©cnica de optimizaci√≥n, se utiliz√≥ la implicaci√≥n (**`->`**) para evitar reevaluaciones innecesarias cuando aplicar gravedad no provoca ningun cambio.

    #### 2. `bucle` (nivel intermedio):

    Se encarga de recorrer una lista de √≠ndices a revisar y, para cada uno, intentar ejecutar una fusi√≥n con `fusion`.\
    Esta etapa nace a partir de una decisi√≥n de dise√±o clave: los bloques formados en una fusi√≥n no deben ser candidatos a otra fusi√≥n dentro del mismo ciclo.

    **Ejemplo:**

    ```
    [4 2 2  ‚Üí   [4 4 -  ‚Üí   [8 4 -
     4 - -]      4 - -]      - - -]
    ```

    En este ejemplo, el nuevo `4` formado no puede fusionarse con los otros     `4`, ya que todos deber√≠an haberse fusionado simult√°neamente, lo cual   no es viable sin paralelismo. Por eso, se ide√≥ el concepto de "ciclo"     de fusiones. Las fusiones dentro de un mismo ciclo solo consideran  bloques anteriores, y sus resultados se usan en el siguiente.

    En cuanto al flujo, `bucle` itera sobre cada √≠ndice a revisar. Llama a  `fusion`, y si esta tiene √©xito, guarda el √≠ndice donde termin√≥. Si  falla, descarta el √≠ndice y contin√∫a.

    > Como t√©cnica de optimizaci√≥n, se utiliz√≥ la implicaci√≥n (**`->`**) para evitar reevaluaciones innecesarias cuando una fusi√≥n no es posible.

    Una vez recorridos todos los √≠ndices, `bucle` retorna:

... (45 l√≠neas restantes)
Contraer
message.txt
11 KB
SAL ‚Äî 19:52

# Informe de la Resoluci√≥n del Proyecto
*M2 Blocks - L√≥gica para Cs. de la Computaci√≥n - 2025*

---
**Comisi√≥n 22**:
Expandir
INFORME.md
44 KB
Ôªø
SAL
alexissala
 
 
# Informe de la Resoluci√≥n del Proyecto
*M2 Blocks - L√≥gica para Cs. de la Computaci√≥n - 2025*

**Comisi√≥n `46`**:
- `Salamanca, Santiago`
- `Santa Mar√≠a, Joaqu√≠n`
---
Dadas las principales funcionales a ser contempladas tal como estan presentadas en el repositorio de GitHub, a continuacion se describir√° como se implementaron.

    - <span style="color:#fc7f40">üìå**Aviso "Combo x N.**</span> 

    La manera en la que se eval√∫a si se mostrar√° el aviso de "Combo xN" est√° completamente manejada en el frontend. Para esto, se aprovecha la misma consulta de disparo que se utiliza para obtener el estado actualizado de la grilla y los efectos que produce la jugada.

    Cuando el jugador dispara un bloque, la respuesta de Prolog incluye una lista de efectos que detallan los cambios ocurridos durante esa jugada. Cada efecto tiene dos componentes:

        -La grilla resultante luego de ese paso.

        -Una lista que puede incluir, los nuevos bloques generados como resultado de fusiones (si es que los hay).

    Desde el frontend, no es necesario realizar consultas extra ni c√°lculos adicionales sobre la grilla. Lo que se hace es recorrer esta lista de efectos y contabilizar cu√°ntos de esos efectos tienen una lista de nuevos bloques (newBlock) no vac√≠a. Cada vez que esa lista contiene al menos un bloque, significa que se produjo una fusi√≥n en ese paso.

    Una vez realizada esta contabilizaci√≥n, si la cantidad de fusiones detectadas es mayor o igual a 3, se activa el aviso en pantalla "Combo xN", donde N corresponde a la cantidad total de fusiones encadenadas en esa jugada.

    Como en el juego original, si en un efecto se fusionan varios bloques distintos, esto a√∫n se cuenta como un solo incremento en el combo. Esta elecci√≥n intenta representar con precisi√≥n el comportamiento del juego base.
    
- <span style="color:#fc7f40">üìå**Generaci√≥n aleatoria del bloque a disparar.**</span> 

    Generaci√≥n aleatoria del bloque a disparar.

    Para determinar el valor del pr√≥ximo bloque, se utiliza un predicado que recibe la grilla actual y calcula un valor aleatorio v√°lido seg√∫n las reglas del juego.

    El proceso comienza identificando el valor m√°ximo actual de la grilla. En funci√≥n de este valor, se define un rango m√≠nimo y m√°ximo dentro del cual se permite generar el siguiente bloque.

    En las primeras etapas de la partida, el rango se establece mediante condiciones fijas basadas en la tabla proporcionada por la catedra en github. Sin embargo, cuando el valor m√°ximo supera los 16.000, se aplica una f√≥rmula espec√≠fica que ajusta el rango de forma proporcional al avance del juego.

    Esta f√≥rmula calcula la cantidad de veces que el valor m√°ximo se ha duplicado respecto de 16.000. La cantidad de duplicaciones se obtiene utilizando el logaritmo base 2. A partir de este valor, se determina el rango permitido seg√∫n las siguientes expresiones:

    M√≠nimo permitido = 2^(5 + K)

    M√°ximo permitido = 2^(10 + K)

    Donde K representa la cantidad de duplicaciones del valor m√°ximo actual respecto de 16.000, calculada como:

    K = piso de log‚ÇÇ(MaxAct / 16000)

    De esta manera, por cada duplicaci√≥n del valor m√°ximo, el rango permitido se desplaza a valores m√°s altos de forma controlada y progresiva.

    Una vez determinado el rango, se filtran todas las potencias de dos dentro de esos l√≠mites y se selecciona aleatoriamente una de ellas como pr√≥ximo bloque a disparar.
- <span style="color:#fc7f40">üìå  **Efecto del disparo de un bloque.**</span> 

    Como parte de las optimizaciones implementadas, se tuvo en cuenta el costo de calcular repetidamente la longitud de la grilla (mediante `length/2`) y la redundancia de que multiples predicados realicen el calculo agregando lineas de codigo que podrian omitirse. Para evitar este sobrecosto, se definieron dos variantes del predicado `shoot`:

    - Una primera versi√≥n se activa √∫nicamente la primera vez que se invoca el disparo. En esta se calcula la longitud total de la grilla y se utiliza `assert/1` para guardar este valor como un hecho din√°mico en la base de conocimiento. Luego, procede con su normal funcionamiento.

    - A partir de entonces, una segunda versi√≥n de `shoot` se encarga de verificar si ese hecho ya existe. Si es as√≠, procede normalmente con `shoot`.

    Esta t√©cnica permite evitar c√°lculos redundantes sin afectar el comportamiento l√≥gico del juego, mejorando ligeramente la eficiencia sin introducir complejidad significativa.

    Para resolver el efecto de disparo de un bloque, el problema fue subdividido en tareas individuales que, combinadas, permiten alcanzar el objetivo. Esta fragmentaci√≥n tambi√©n permiti√≥ la reutilizaci√≥n de predicados en otras partes del juego.

    Primero, se dise√±√≥ un predicado encargado de insertar el bloque reci√©n disparado en la grilla. Esto significa que, dado el bloque y la columna de disparo, el predicado lo ubica en el √∫ltimo espacio vac√≠o de esa columna antes de encontrarse con un bloque existente o el final de la grilla.

    Este proceso se realiza sobre la grilla, que est√° representada como una lista unidimensional. Dada la cantidad de columnas y la columna seleccionada, se calculan los √≠ndices correspondientes a esa columna. Luego se recorren esos √≠ndices, desde los m√°s bajos hasta los m√°s altos, buscando una celda vac√≠a (representada por un gui√≥n). Si no hay espacio disponible, el predicado no realiza cambios. Si logra insertarlo, se retorna la nueva grilla junto con el √≠ndice de inserci√≥n.

    Una vez insertado el bloque, entra en juego el predicado m√°s importante del sistema: el encargado de identificar y ejecutar las fusiones disponibles, respetando las reglas del juego original.

    ### üîπ Estructura jer√°rquica de resoluci√≥n de fusiones

    El n√∫cleo de la l√≥gica del juego se basa en tres niveles de predicados encadenados de forma jer√°rquica:

    #### 1. `admin` (nivel superior):

    Controla el ciclo completo del disparo de un bloque. Se encarga de:

    - Invocar a `bucle` para identificar fusiones iniciales  a partir del √≠ndice del nuevo bloque.
    - Aplicar la gravedad una vez que se realizaron fusiones.
    - Invocar nuevamente `bucle` para revisar nuevas posibles fusiones  que puedan haber surgido tras la ca√≠da de bloques y fusiones previas.

    > Como t√©cnica de optimizaci√≥n, se utiliz√≥ la implicaci√≥n (**`->`**) para evitar reevaluaciones innecesarias cuando aplicar gravedad no provoca ningun cambio.

    #### 2. `bucle` (nivel intermedio):

    Se encarga de recorrer una lista de √≠ndices a revisar y, para cada uno, intentar ejecutar una fusi√≥n con `fusion`.\
    Esta etapa nace a partir de una decisi√≥n de dise√±o clave: los bloques formados en una fusi√≥n no deben ser candidatos a otra fusi√≥n dentro del mismo ciclo.

    **Ejemplo:**

    ```
    [4 2 2  ‚Üí   [4 4 -  ‚Üí   [8 4 -
     4 - -]      4 - -]      - - -]
    ```

    En este ejemplo, el nuevo `4` formado no puede fusionarse con los otros     `4`, ya que todos deber√≠an haberse fusionado simult√°neamente, lo cual   no es viable sin paralelismo. Por eso, se ide√≥ el concepto de "ciclo"     de fusiones. Las fusiones dentro de un mismo ciclo solo consideran  bloques anteriores, y sus resultados se usan en el siguiente.

    En cuanto al flujo, `bucle` itera sobre cada √≠ndice a revisar. Llama a  `fusion`, y si esta tiene √©xito, guarda el √≠ndice donde termin√≥. Si  falla, descarta el √≠ndice y contin√∫a.

    > Como t√©cnica de optimizaci√≥n, se utiliz√≥ la implicaci√≥n (**`->`**) para evitar reevaluaciones innecesarias cuando una fusi√≥n no es posible.

    Una vez recorridos todos los √≠ndices, `bucle` retorna:

    - Los √≠ndices finales de las fusiones realizadas
    - La grilla resultante
    - La lista de nuevos bloques `newblock` formados

    Los nuevos indices ser√°n utilizados por `admin` para aplicar relanzar el ciclo. La grilla resultante y los nuevos bloques formados ser√°n utilizados para la creacion de efectos.

    #### 3. `fusion` (nivel inferior):

    Es el n√∫cleo de la l√≥gica de combinaci√≥n de bloques. A pesar de ser el √∫ltimo paso de la fusi√≥n, est√° compuesto por varios subpredicados.

    Recibe (entre otras cosas): 
    - El √≠ndice a revisar
    - Una lista de bloques "inv√°lidos" (formados en el mismo ciclo) 

    Su tarea es:    
    1. Verificar si el bloque en ese √≠ndice puede fusionarse con alg√∫n  adyacente (predicado aparte).
    2. Evaluar si hay alg√∫n adyacente que sea mejor candidato para la   fusi√≥n, seg√∫n los posibles resultados futuros (predicado aparte).
    3. Considerar las reglas espec√≠ficas del juego original:
       - Si solo puede fusionar con un bloque "arriba", la fusi√≥n se    hace hacia arriba.
       - Si hay un mejor candidato adyacente que produce una mejor  fusi√≥n, se prioriza ese bloque.  
 
    Finalmente, retorna:    
    - El √≠ndice donde termin√≥ la fusi√≥n
    - El nuevo bloque `newblock`
    - La grilla modificada
     
    Luego de completar todas las fusiones posibles, se procede a revisar si se gener√≥ un nuevo bloque m√°ximo en la grilla y se eliminan los  bloques que ya no est√°n en uso. La descripci√≥n de este proceso se encuentra m√°s adelante en el informe.

    ---

    ### üîΩ Aplicaci√≥n de la gravedad

    Una vez concluidas las fusiones en una grilla, es posible que queden espacios vac√≠os entre bloques, debido a que algunas celdas fueron liberadas tras las combinaciones. Para simular el efecto de la gravedad, se dise√±√≥ un mecanismo que reorganiza los bloques de las columnas, haciendo que los espacios vac√≠os se acumulen en los √≠ndices superiores de la grilla, es decir, en la parte inferior de la pantalla.

    Esto se logra recibiendo los √≠ndices de las columnas que deben ser  reorganizadas. Dichas columnas se obtienen a partir de un predicado que  utiliza los √≠ndices donde culminaron las fusiones, calcula a qu√© columnas pertenecen y agrega tambi√©n las columnas adyacentes, todo esto sin repeticiones.

    Una vez identificadas las columnas a reorganizar, se extraen    individualmente de la grilla, se reordenan y luego se reinsertan en su posici√≥n original.

    Este procedimiento se repite para cada columna seleccionada,    garantizando as√≠ que el efecto de gravedad se aplique √∫nicamente donde sea necesario antes de buscar nuevas fusiones.

    Finalmente, retorna:
    - Los √≠ndices donde cayeron bloques tras la aplicaci√≥n de la gravedad
    - La grilla modificada

    Cabe destacar que este proceso fue dise√±ado para aplicar la gravedad solo donde es necesario. Si bien no representa una mejora significativa en rendimiento en el caso actual, permite escalar el juego a una versi√≥n con m√°s columnas y filas sin comprometer la eficiencia.