# Informe de la Resoluci√≥n del Proyecto
*M2 Blocks - L√≥gica para Cs. de la Computaci√≥n - 2025*

**Comisi√≥n `46`**:
- `Salamanca, Santiago`
- `Santa Mar√≠a, Joaqu√≠n`
---
Dadas las principales funcionalidades a ser contempladas tal como estan presentadas en el repositorio de GitHub, a continuacion se describir√° como se implementaron.

- <span style="color:#fc7f40">üìå**Aviso "Combo x N.**</span> 

    La manera en la que se eval√∫a si se mostrar√° el aviso de "Combo xN" est√° completamente manejada en el frontend. Para esto, se aprovecha la misma consulta de disparo que se utiliza para obtener el estado actualizado de la grilla y los efectos que produce la jugada.

    Cuando el jugador dispara un bloque, la respuesta de Prolog incluye una lista de efectos que detallan los cambios ocurridos durante esa jugada. Cada efecto tiene dos componentes:

        -La grilla resultante luego de ese paso.

        -Una lista que puede incluir, los nuevos bloques generados como resultado de fusiones (si es que los hay).

    Desde el frontend, no es necesario realizar consultas extra ni c√°lculos adicionales sobre la grilla. Lo que se hace es recorrer esta lista de efectos y contabilizar cu√°ntos de esos efectos tienen una lista de nuevos bloques (newBlock) no vac√≠a. Cada vez que esa lista contiene al menos un bloque, significa que se produjo una fusi√≥n en ese paso.

    Una vez realizada esta contabilizaci√≥n, si la cantidad de fusiones detectadas es mayor o igual a 3, se activa el aviso en pantalla "Combo xN", donde N corresponde a la cantidad total de fusiones encadenadas en esa jugada.

    Como en el juego original, si en un efecto se fusionan varios bloques distintos, esto a√∫n se cuenta como un solo incremento en el combo. Esta elecci√≥n intenta representar con precisi√≥n el comportamiento del juego base.
    
- <span style="color:#fc7f40">üìå**Generaci√≥n aleatoria del bloque a disparar.**</span> 

    Generaci√≥n aleatoria del bloque a disparar.

    Para determinar el valor del pr√≥ximo bloque, se utiliza un predicado que recibe la grilla actual y calcula un valor aleatorio v√°lido seg√∫n las reglas del juego.

    El proceso comienza identificando el valor m√°ximo actual de la grilla. En funci√≥n de este valor, se define un rango m√≠nimo y m√°ximo dentro del cual se permite generar el siguiente bloque.

    En las primeras etapas de la partida, el rango se establece mediante condiciones fijas basadas en la tabla proporcionada por la catedra en github. Sin embargo, cuando el valor m√°ximo supera los 16.000, se aplica una f√≥rmula espec√≠fica que ajusta el rango de forma proporcional al avance del juego.

    Esta f√≥rmula calcula la cantidad de veces que el valor m√°ximo se ha duplicado respecto de 16.000. La cantidad de duplicaciones se obtiene utilizando el logaritmo base 2. A partir de este valor, se determina el rango permitido seg√∫n las siguientes expresiones:

    M√≠nimo permitido = 2^(5 + K)

    M√°ximo permitido = 2^(10 + K)

    Donde K representa la cantidad de duplicaciones del valor m√°ximo actual respecto de 16.000, calculada como:

    K = piso de log‚ÇÇ(MaxAct / 16000)

    De esta manera, por cada duplicaci√≥n del valor m√°ximo, el rango permitido se desplaza a valores m√°s altos de forma controlada y progresiva.

    Una vez determinado el rango, se filtran todas las potencias de dos dentro de esos l√≠mites y se selecciona aleatoriamente una de ellas como pr√≥ximo bloque a disparar.
- <span style="color:#fc7f40">üìå  **Efecto del disparo de un bloque.**</span> 

    Como parte de las optimizaciones implementadas, se tuvo en cuenta el costo de calcular repetidamente la longitud de la grilla (mediante `length/2`) y la redundancia de que multiples predicados realicen el calculo agregando lineas de codigo que podrian omitirse. Para evitar este sobrecosto, se definieron dos variantes del predicado `shoot`:

    - Una primera versi√≥n se activa √∫nicamente la primera vez que se invoca el disparo. En esta se calcula la longitud total de la grilla y se utiliza `assert/1` para guardar este valor como un hecho din√°mico en la base de conocimiento. Luego, procede con su normal funcionamiento.

    - A partir de entonces, una segunda versi√≥n de `shoot` se encarga de verificar si ese hecho ya existe. Si es as√≠, procede normalmente con `shoot`.

    Esta t√©cnica permite evitar c√°lculos redundantes sin afectar el comportamiento l√≥gico del juego, mejorando ligeramente la eficiencia sin introducir complejidad significativa.

    Para resolver el efecto de disparo de un bloque, el problema fue subdividido en tareas individuales que, combinadas, permiten alcanzar el objetivo. Esta fragmentaci√≥n tambi√©n permiti√≥ la reutilizaci√≥n de predicados en otras partes del juego.

    Primero, se dise√±√≥ un predicado encargado de insertar el bloque reci√©n disparado en la grilla. Esto significa que, dado el bloque y la columna de disparo, el predicado lo ubica en el √∫ltimo espacio vac√≠o de esa columna antes de encontrarse con un bloque existente o el final de la grilla.

    Este proceso se realiza sobre la grilla, que est√° representada como una lista unidimensional. Dada la cantidad de columnas y la columna seleccionada, se calculan los √≠ndices correspondientes a esa columna. Luego se recorren esos √≠ndices, desde los m√°s bajos hasta los m√°s altos, buscando una celda vac√≠a (representada por un gui√≥n). Si no hay espacio disponible, el predicado no realiza cambios. Si logra insertarlo, se retorna la nueva grilla junto con el √≠ndice de inserci√≥n.

    Una vez insertado el bloque, entra en juego el predicado m√°s importante del sistema: el encargado de identificar y ejecutar las fusiones disponibles, respetando las reglas del juego original.

    ### üîπ Estructura jer√°rquica de resoluci√≥n de fusiones

    El n√∫cleo de la l√≥gica del juego se basa en tres niveles de predicados encadenados de forma jer√°rquica:

    #### 1. `admin` (nivel superior):

    Controla el ciclo completo del disparo de un bloque. Se encarga de:

    - Invocar a `bucle` para identificar fusiones iniciales  a partir del √≠ndice del nuevo bloque.
    - Aplicar la gravedad una vez que se realizaron fusiones.
    - Invocar nuevamente `bucle` para revisar nuevas posibles fusiones  que puedan haber surgido tras la ca√≠da de bloques y fusiones previas.

    > Como t√©cnica de optimizaci√≥n, se utiliz√≥ la implicaci√≥n (**`->`**) para evitar reevaluaciones innecesarias cuando aplicar gravedad no provoca ningun cambio.

    #### 2. `bucle` (nivel intermedio):

    Se encarga de recorrer una lista de √≠ndices a revisar y, para cada uno, intentar ejecutar una fusi√≥n con `fusion`.\
    Esta etapa nace a partir de una decisi√≥n de dise√±o clave: los bloques formados en una fusi√≥n no deben ser candidatos a otra fusi√≥n dentro del mismo ciclo.

    **Ejemplo:**

    ```
    [4 2 2  ‚Üí   [4 4 -  ‚Üí   [8 4 -
     4 - -]      4 - -]      - - -]
    ```

    En este ejemplo, el nuevo `4` formado no puede fusionarse con los otros     `4`, ya que todos deber√≠an haberse fusionado simult√°neamente, lo cual   no es viable sin paralelismo. Por eso, se ide√≥ el concepto de "ciclo"     de fusiones. Las fusiones dentro de un mismo ciclo solo consideran  bloques anteriores, y sus resultados se usan en el siguiente.

    En cuanto al flujo, `bucle` itera sobre cada √≠ndice a revisar. Llama a  `fusion`, y si esta tiene √©xito, guarda el √≠ndice donde termin√≥. Si  falla, descarta el √≠ndice y contin√∫a.

    > Como t√©cnica de optimizaci√≥n, se utiliz√≥ la implicaci√≥n (**`->`**) para evitar reevaluaciones innecesarias cuando una fusi√≥n no es posible.

    Una vez recorridos todos los √≠ndices, `bucle` retorna:

    - Los √≠ndices finales de las fusiones realizadas
    - La grilla resultante
    - La lista de nuevos bloques `newblock` formados

    Los nuevos indices ser√°n utilizados por `admin` para aplicar relanzar el ciclo. La grilla resultante y los nuevos bloques formados ser√°n utilizados para la creacion de efectos.

    #### 3. `fusion` (nivel inferior):

    Es el n√∫cleo de la l√≥gica de combinaci√≥n de bloques. A pesar de ser el √∫ltimo paso de la fusi√≥n, est√° compuesto por varios subpredicados.

    Recibe (entre otras cosas): 
    - El √≠ndice a revisar
    - Una lista de bloques "inv√°lidos" (formados en el mismo ciclo) 

    Su tarea es:    
    1. Verificar si el bloque en ese √≠ndice puede fusionarse con alg√∫n  adyacente (predicado aparte).
    2. Evaluar si hay alg√∫n adyacente que sea mejor candidato para la   fusi√≥n, seg√∫n los posibles resultados futuros (predicado aparte).
    3. Considerar las reglas espec√≠ficas del juego original:
       - Si solo puede fusionar con un bloque "arriba", la fusi√≥n se    hace hacia arriba.
       - Si hay un mejor candidato adyacente que produce una mejor  fusi√≥n, se prioriza ese bloque.  
 
    Finalmente, retorna:    
    - El √≠ndice donde termin√≥ la fusi√≥n
    - El nuevo bloque `newblock`
    - La grilla modificada
     
    Luego de completar todas las fusiones posibles, se procede a revisar si se gener√≥ un nuevo bloque m√°ximo en la grilla y se eliminan los  bloques que ya no est√°n en uso. La descripci√≥n de este proceso se encuentra m√°s adelante en el informe.

    ---

    ### üîΩ Aplicaci√≥n de la gravedad

    Una vez concluidas las fusiones en una grilla, es posible que queden espacios vac√≠os entre bloques, debido a que algunas celdas fueron liberadas tras las combinaciones. Para simular el efecto de la gravedad, se dise√±√≥ un mecanismo que reorganiza los bloques de las columnas, haciendo que los espacios vac√≠os se acumulen en los √≠ndices superiores de la grilla, es decir, en la parte inferior de la pantalla.

    Esto se logra recibiendo los √≠ndices de las columnas que deben ser  reorganizadas. Dichas columnas se obtienen a partir de un predicado que  utiliza los √≠ndices donde culminaron las fusiones, calcula a qu√© columnas pertenecen y agrega tambi√©n las columnas adyacentes, todo esto sin repeticiones.

    Una vez identificadas las columnas a reorganizar, se extraen    individualmente de la grilla, se reordenan y luego se reinsertan en su posici√≥n original.

    Este procedimiento se repite para cada columna seleccionada,    garantizando as√≠ que el efecto de gravedad se aplique √∫nicamente donde sea necesario antes de buscar nuevas fusiones.

    Finalmente, retorna:
    - Los √≠ndices donde cayeron bloques tras la aplicaci√≥n de la gravedad
    - La grilla modificada

    Cabe destacar que este proceso fue dise√±ado para aplicar la gravedad solo donde es necesario. Si bien no representa una mejora significativa en rendimiento en el caso actual, permite escalar el juego a una versi√≥n con m√°s columnas y filas sin comprometer la eficiencia.